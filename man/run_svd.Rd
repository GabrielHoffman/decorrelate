% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run_svd.R
\name{run_svd}
\alias{run_svd}
\title{Compute SVD with selected algorithm}
\usage{
run_svd(X, k = min(dim(X)), method = c("svd", "irlba", "pcaone"), ...)
}
\arguments{
\item{X}{data matrix}

\item{k}{number of left and right singular values to compute}

\item{method}{SVD algorithm string "svd", "irlba", or "pcaone"}

\item{...}{other arguments passed to SVD functions}
}
\description{
Compute SVD using exact, approximate or randomized algorithms
}
\details{
Compute SVD using select algorithm.  Let data matrix \code{X} have \code{n} rows and \code{p} columns.  At most \code{min(n,p)} singular vectors can be computed.
\itemize{
 \item "svd": exact algorithm using standard \code{svd()} function.  Fastest choice if computing greater than about \code{min(n,p)/3} singular vectors.

 \item "irlba": approximate algorithm using implicitly restarted Lanczos bidiagonalization in \code{irlba::irlba()}.  Much faster than "svd" for computing less than about \code{min(n,p)/3}  singular vectors, while matching \code{svd()} to moderate precision

 \item "pcaone": randomized SVD algorithm implemented in \code{pcaone::pcaone()}.  Fastest method for large datasets, when computing about \code{min(n,p)/3}  singular vectors.  Singular vectors and values are approximate and can differ from \code{svd()} by a few percent.  
}
}
\examples{
hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, `+`) }
X <- hilbert(9)[, 1:6]
dcmp1 <- run_svd(X, method = "svd")
dcmp2 <- run_svd(X, method = "irlba")
dcmp3 <- run_svd(X, method = "pcaone")

}
