
Papers:
	https://openreview.net/pdf?id=4sCyjwaVtZ9
	https://www-users.cs.umn.edu/~saad/PDF/ys-2013-6.pdf
	https://arxiv.org/pdf/1904.03441.pdf


DONE: see eclairs(...,fastLambda=TRUE)
1) Estimate lambda faster using only dSq, n, p?
	No, estimation of lambda uses *unbiased* method

2) Better description of decorralate
	#'' FIX NOTATION HERE:

3)	SVD recycle
	better warmStart with ilrba
	https://github.com/bwlewis/irlba/issues/58

	Use PRIMME::svds to do iterative SVD with warm start

DONE: 4) simulate multivariate normal using eclairs

DONE: 5) Parametric boostrap to get SVD of log(t^2)

DONE: 6) Currently eclairs only shrinks to target identity matrix.
	Expandt to covariance matrix with constant variance nu.

DONE: see decorrelate.Rmd
	7) Show effect of lambda on transformation	

show time versus dimension curve for eclair + decorrelate compared to naive method.

DONE: Additional testing on lm_eclairs(), add unit tests

DONE: added lm_eclairs()

	Joint analysis to score annotations
		joint_lm_eclairs = function(formula, data){

			fit = lm(y.transform ~ ., data)

			or use mr.ash or vrbs?
			
		}

decorrelate() working on transposed data
	check dimension of X vs U and report error

DONE
lm_eclairs() and lm_each_eclairs()
	This function fit a linear regression to the transformed response, and transformed design matrix.  Note that the design matrix, not just the data.frame of variables is transformed so that 1) factors are transformed and 2) the intercept term is transformed.  

DONE
	eclairs_reform() to compute SVD after dropping features


DONE
This spends a substantial amount of time in t() within mult_eclairs()
Need a faster way to handle this, since transpose=TRUE is a bottneck
	
	X = matrnorm(p, 10000)
	colnames(X) = paste0('set_', 1:ncol(X))

	system.time({
	res <- lm_each_eclairs(y ~ v1 + v2, data, X, ecl )
	})

	sweep, mapply, Rfast each, X %*% diag(), X %*% Diagonal()

DONE
	assign sign consistancy with in eclairs() and reform_decomp()



a special case is identical to whiten
	ecl <- eclairs(Y, compute="covariance", lambda=0)
	Z1 <- decorrelate(Y, ecl)
	Z2 = whiten(Y)
	checkEqualsNumeric(Z1, Z2)

implicit whitening matrix
shrinkage
compute="correlation" rotates but keeps scale










